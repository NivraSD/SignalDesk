<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SignalDesk Production Issues Diagnostic</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
            background: #f5f5f5;
        }
        .container {
            background: white;
            border-radius: 8px;
            padding: 30px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        h1 {
            color: #333;
            border-bottom: 3px solid #007bff;
            padding-bottom: 10px;
        }
        h2 {
            color: #555;
            margin-top: 30px;
        }
        .test-section {
            background: #f9f9f9;
            border-left: 4px solid #007bff;
            padding: 15px;
            margin: 20px 0;
        }
        .result {
            padding: 10px;
            margin: 10px 0;
            border-radius: 4px;
            font-family: monospace;
            white-space: pre-wrap;
            word-wrap: break-word;
        }
        .success {
            background: #d4edda;
            border: 1px solid #c3e6cb;
            color: #155724;
        }
        .error {
            background: #f8d7da;
            border: 1px solid #f5c6cb;
            color: #721c24;
        }
        .warning {
            background: #fff3cd;
            border: 1px solid #ffeeba;
            color: #856404;
        }
        .info {
            background: #d1ecf1;
            border: 1px solid #bee5eb;
            color: #0c5460;
        }
        button {
            background: #007bff;
            color: white;
            border: none;
            padding: 10px 20px;
            border-radius: 4px;
            cursor: pointer;
            margin: 5px;
            font-size: 16px;
        }
        button:hover {
            background: #0056b3;
        }
        .btn-secondary {
            background: #6c757d;
        }
        .btn-secondary:hover {
            background: #545b62;
        }
        .btn-success {
            background: #28a745;
        }
        .btn-success:hover {
            background: #218838;
        }
        input, select, textarea {
            width: 100%;
            padding: 8px;
            margin: 5px 0;
            border: 1px solid #ddd;
            border-radius: 4px;
        }
        .grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
            margin: 20px 0;
        }
        .status-indicator {
            display: inline-block;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .status-good { background: #28a745; }
        .status-bad { background: #dc3545; }
        .status-unknown { background: #ffc107; }
        .loading {
            display: inline-block;
            border: 3px solid #f3f3f3;
            border-top: 3px solid #3498db;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            animation: spin 1s linear infinite;
        }
        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }
    </style>
</head>
<body>
    <div class="container">
        <h1>üîç SignalDesk Production Issues Diagnostic</h1>
        
        <div class="test-section">
            <h2>‚öôÔ∏è Environment Configuration</h2>
            <div class="grid">
                <div>
                    <label>Frontend URL (Vercel):</label>
                    <input type="text" id="frontendUrl" placeholder="https://your-app.vercel.app" />
                </div>
                <div>
                    <label>Backend URL (Railway):</label>
                    <input type="text" id="backendUrl" placeholder="https://your-backend.railway.app" />
                </div>
            </div>
            <button onclick="saveConfig()">Save Configuration</button>
            <button onclick="loadSavedConfig()" class="btn-secondary">Load Saved Config</button>
        </div>

        <div class="test-section">
            <h2>üè• Health Checks</h2>
            <button onclick="runAllHealthChecks()">Run All Health Checks</button>
            <div id="healthResults"></div>
        </div>

        <div class="test-section">
            <h2>üîë API Key & Environment Variables</h2>
            <button onclick="checkEnvironmentVariables()">Check Environment Variables</button>
            <div id="envResults"></div>
        </div>

        <div class="test-section">
            <h2>üìù Content Generation Test</h2>
            <div>
                <label>Content Type:</label>
                <select id="contentType">
                    <option value="blog">Blog Post</option>
                    <option value="press-release">Press Release</option>
                    <option value="social">Social Media</option>
                    <option value="email">Email</option>
                </select>
            </div>
            <div>
                <label>Test Prompt:</label>
                <textarea id="contentPrompt" rows="3">Write a brief announcement about a new product launch</textarea>
            </div>
            <button onclick="testContentGeneration()">Test Content Generation</button>
            <div id="contentResults"></div>
        </div>

        <div class="test-section">
            <h2>üí¨ AI Chat Session Test</h2>
            <button onclick="testChatSession()">Test Chat Session (Multiple Messages)</button>
            <div id="chatResults"></div>
        </div>

        <div class="test-section">
            <h2>üîç Detailed API Diagnostics</h2>
            <button onclick="runDetailedDiagnostics()">Run Detailed Diagnostics</button>
            <div id="diagnosticResults"></div>
        </div>

        <div class="test-section">
            <h2>üìä Summary & Recommendations</h2>
            <button onclick="generateSummary()" class="btn-success">Generate Summary Report</button>
            <div id="summaryResults"></div>
        </div>
    </div>

    <script>
        // Store test results
        let testResults = {
            health: {},
            environment: {},
            content: {},
            chat: {},
            diagnostics: {}
        };

        // Load saved configuration
        function loadSavedConfig() {
            const saved = localStorage.getItem('signaldesk_test_config');
            if (saved) {
                const config = JSON.parse(saved);
                document.getElementById('frontendUrl').value = config.frontendUrl || '';
                document.getElementById('backendUrl').value = config.backendUrl || '';
                showResult('info', 'Configuration loaded from local storage', 'healthResults');
            } else {
                // Try to detect from current URL
                if (window.location.hostname.includes('vercel')) {
                    document.getElementById('frontendUrl').value = window.location.origin;
                }
                showResult('warning', 'No saved configuration found', 'healthResults');
            }
        }

        // Save configuration
        function saveConfig() {
            const config = {
                frontendUrl: document.getElementById('frontendUrl').value,
                backendUrl: document.getElementById('backendUrl').value
            };
            localStorage.setItem('signaldesk_test_config', JSON.stringify(config));
            showResult('success', 'Configuration saved', 'healthResults');
        }

        // Helper function to show results
        function showResult(type, message, targetId) {
            const target = document.getElementById(targetId);
            const div = document.createElement('div');
            div.className = `result ${type}`;
            div.textContent = message;
            target.appendChild(div);
        }

        // Clear results
        function clearResults(targetId) {
            document.getElementById(targetId).innerHTML = '';
        }

        // Get backend URL
        function getBackendUrl() {
            const url = document.getElementById('backendUrl').value;
            if (!url) {
                alert('Please enter the backend URL first');
                return null;
            }
            return url.replace(/\/$/, ''); // Remove trailing slash
        }

        // Run all health checks
        async function runAllHealthChecks() {
            clearResults('healthResults');
            const backendUrl = getBackendUrl();
            if (!backendUrl) return;

            showResult('info', 'Starting health checks...', 'healthResults');

            // Test 1: Backend Health Check
            try {
                showResult('info', 'Testing backend health endpoint...', 'healthResults');
                const healthRes = await fetch(`${backendUrl}/api/health`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (healthRes.ok) {
                    const data = await healthRes.json();
                    testResults.health.backend = true;
                    showResult('success', `‚úÖ Backend is healthy: ${JSON.stringify(data)}`, 'healthResults');
                } else {
                    testResults.health.backend = false;
                    showResult('error', `‚ùå Backend health check failed: ${healthRes.status} ${healthRes.statusText}`, 'healthResults');
                }
            } catch (error) {
                testResults.health.backend = false;
                showResult('error', `‚ùå Backend unreachable: ${error.message}`, 'healthResults');
                showResult('warning', 'Possible CORS issue or backend is down', 'healthResults');
            }

            // Test 2: CORS Check
            try {
                showResult('info', 'Testing CORS configuration...', 'healthResults');
                const corsRes = await fetch(`${backendUrl}/api/health`, {
                    method: 'OPTIONS',
                    headers: {
                        'Origin': window.location.origin,
                        'Access-Control-Request-Method': 'POST',
                        'Access-Control-Request-Headers': 'Content-Type'
                    }
                });
                
                const corsHeaders = corsRes.headers.get('access-control-allow-origin');
                if (corsHeaders) {
                    testResults.health.cors = true;
                    showResult('success', `‚úÖ CORS configured: ${corsHeaders}`, 'healthResults');
                } else {
                    testResults.health.cors = false;
                    showResult('warning', '‚ö†Ô∏è CORS headers not found', 'healthResults');
                }
            } catch (error) {
                testResults.health.cors = false;
                showResult('error', `‚ùå CORS test failed: ${error.message}`, 'healthResults');
            }

            // Test 3: Database Connection
            try {
                showResult('info', 'Testing database connection...', 'healthResults');
                const dbRes = await fetch(`${backendUrl}/api/test/database`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });
                
                if (dbRes.ok) {
                    testResults.health.database = true;
                    showResult('success', '‚úÖ Database connection successful', 'healthResults');
                } else {
                    testResults.health.database = false;
                    showResult('error', '‚ùå Database connection failed', 'healthResults');
                }
            } catch (error) {
                testResults.health.database = false;
                showResult('warning', `‚ö†Ô∏è Database test endpoint not available`, 'healthResults');
            }
        }

        // Check environment variables
        async function checkEnvironmentVariables() {
            clearResults('envResults');
            const backendUrl = getBackendUrl();
            if (!backendUrl) return;

            showResult('info', 'Checking environment variables...', 'envResults');

            try {
                const envRes = await fetch(`${backendUrl}/api/test/env`, {
                    method: 'GET',
                    headers: { 'Content-Type': 'application/json' }
                });

                if (envRes.ok) {
                    const data = await envRes.json();
                    testResults.environment = data;
                    
                    // Check critical variables
                    const critical = ['ANTHROPIC_API_KEY', 'DATABASE_URL', 'NODE_ENV'];
                    critical.forEach(key => {
                        if (data[key]) {
                            showResult('success', `‚úÖ ${key} is configured`, 'envResults');
                        } else {
                            showResult('error', `‚ùå ${key} is NOT configured`, 'envResults');
                        }
                    });
                    
                    // Show all environment info
                    showResult('info', `Full environment info:\n${JSON.stringify(data, null, 2)}`, 'envResults');
                } else {
                    showResult('warning', 'Environment test endpoint not available - this is normal for security', 'envResults');
                    
                    // Try indirect test
                    showResult('info', 'Attempting indirect environment test...', 'envResults');
                    const testRes = await fetch(`${backendUrl}/api/content/test-claude`, {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ test: true })
                    });
                    
                    if (testRes.ok) {
                        showResult('success', '‚úÖ Claude API appears to be configured', 'envResults');
                    } else {
                        showResult('error', '‚ùå Claude API may not be properly configured', 'envResults');
                    }
                }
            } catch (error) {
                showResult('error', `Failed to check environment: ${error.message}`, 'envResults');
            }
        }

        // Test content generation
        async function testContentGeneration() {
            clearResults('contentResults');
            const backendUrl = getBackendUrl();
            if (!backendUrl) return;

            const contentType = document.getElementById('contentType').value;
            const prompt = document.getElementById('contentPrompt').value;

            showResult('info', `Testing content generation for type: ${contentType}...`, 'contentResults');

            try {
                const startTime = Date.now();
                const res = await fetch(`${backendUrl}/api/content/generate`, {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('token') || 'test-token'}`
                    },
                    body: JSON.stringify({
                        prompt: prompt,
                        contentType: contentType,
                        contentTypeId: contentType,
                        type: contentType
                    })
                });

                const responseTime = Date.now() - startTime;
                showResult('info', `Response time: ${responseTime}ms`, 'contentResults');

                if (res.ok) {
                    const data = await res.json();
                    testResults.content.success = true;
                    testResults.content.responseTime = responseTime;
                    
                    showResult('success', '‚úÖ Content generation successful!', 'contentResults');
                    showResult('info', `Generated content preview:\n${data.content?.substring(0, 200)}...`, 'contentResults');
                    
                    // Check if it's fallback content
                    if (data.content?.includes('[Company Name]') || data.content?.includes('Lorem ipsum')) {
                        showResult('warning', '‚ö†Ô∏è This appears to be fallback content - Claude API may not be working', 'contentResults');
                    }
                } else {
                    testResults.content.success = false;
                    const errorData = await res.text();
                    showResult('error', `‚ùå Content generation failed: ${res.status}\n${errorData}`, 'contentResults');
                }
            } catch (error) {
                testResults.content.success = false;
                showResult('error', `‚ùå Request failed: ${error.message}`, 'contentResults');
            }
        }

        // Test chat session
        async function testChatSession() {
            clearResults('chatResults');
            const backendUrl = getBackendUrl();
            if (!backendUrl) return;

            showResult('info', 'Testing chat session with multiple messages...', 'chatResults');

            const messages = [
                "Hello, can you help me with PR strategy?",
                "What are the key elements of a press release?",
                "Can you give me an example?",
                "Thanks, that's helpful!"
            ];

            let conversationHistory = [];
            let sessionId = null;

            for (let i = 0; i < messages.length; i++) {
                showResult('info', `Sending message ${i + 1}: "${messages[i]}"`, 'chatResults');

                try {
                    const res = await fetch(`${backendUrl}/api/ai/chat`, {
                        method: 'POST',
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token') || 'test-token'}`
                        },
                        body: JSON.stringify({
                            message: messages[i],
                            conversationHistory: conversationHistory,
                            sessionId: sessionId
                        })
                    });

                    if (res.ok) {
                        const data = await res.json();
                        sessionId = data.sessionId || sessionId;
                        
                        showResult('success', `‚úÖ Message ${i + 1} successful`, 'chatResults');
                        showResult('info', `Response preview: ${data.response?.substring(0, 100)}...`, 'chatResults');
                        
                        // Update conversation history
                        conversationHistory.push({ role: 'user', content: messages[i] });
                        conversationHistory.push({ role: 'assistant', content: data.response });
                        
                        // Check if session is maintained
                        if (i > 0 && !data.contextMaintained) {
                            showResult('warning', '‚ö†Ô∏è Chat context may have been reset!', 'chatResults');
                            testResults.chat.contextMaintained = false;
                        }
                    } else {
                        showResult('error', `‚ùå Message ${i + 1} failed: ${res.status}`, 'chatResults');
                        break;
                    }

                    // Wait a bit between messages
                    await new Promise(resolve => setTimeout(resolve, 1000));
                } catch (error) {
                    showResult('error', `‚ùå Chat test failed: ${error.message}`, 'chatResults');
                    break;
                }
            }

            if (conversationHistory.length >= messages.length * 2) {
                testResults.chat.success = true;
                showResult('success', '‚úÖ Chat session test completed successfully', 'chatResults');
            } else {
                testResults.chat.success = false;
                showResult('error', '‚ùå Chat session test failed - conversation was interrupted', 'chatResults');
            }
        }

        // Run detailed diagnostics
        async function runDetailedDiagnostics() {
            clearResults('diagnosticResults');
            const backendUrl = getBackendUrl();
            if (!backendUrl) return;

            showResult('info', 'Running detailed diagnostics...', 'diagnosticResults');

            // Test various endpoints
            const endpoints = [
                { path: '/api/health', method: 'GET', name: 'Health Check' },
                { path: '/api/content/types', method: 'GET', name: 'Content Types' },
                { path: '/api/ai/status', method: 'GET', name: 'AI Status' },
                { path: '/api/projects', method: 'GET', name: 'Projects List' }
            ];

            for (const endpoint of endpoints) {
                try {
                    showResult('info', `Testing ${endpoint.name}...`, 'diagnosticResults');
                    const res = await fetch(`${backendUrl}${endpoint.path}`, {
                        method: endpoint.method,
                        headers: { 
                            'Content-Type': 'application/json',
                            'Authorization': `Bearer ${localStorage.getItem('token') || 'test-token'}`
                        }
                    });

                    if (res.ok) {
                        showResult('success', `‚úÖ ${endpoint.name}: Working (${res.status})`, 'diagnosticResults');
                    } else {
                        showResult('error', `‚ùå ${endpoint.name}: Failed (${res.status})`, 'diagnosticResults');
                    }
                } catch (error) {
                    showResult('error', `‚ùå ${endpoint.name}: ${error.message}`, 'diagnosticResults');
                }
            }

            // Check WebSocket connection
            try {
                showResult('info', 'Testing WebSocket connection...', 'diagnosticResults');
                const wsUrl = backendUrl.replace('https://', 'wss://').replace('http://', 'ws://');
                const ws = new WebSocket(`${wsUrl}/ws`);
                
                ws.onopen = () => {
                    showResult('success', '‚úÖ WebSocket connection established', 'diagnosticResults');
                    ws.close();
                };
                
                ws.onerror = (error) => {
                    showResult('warning', '‚ö†Ô∏è WebSocket connection failed - this may affect chat persistence', 'diagnosticResults');
                };
                
                setTimeout(() => {
                    if (ws.readyState !== WebSocket.OPEN && ws.readyState !== WebSocket.CLOSED) {
                        showResult('warning', '‚ö†Ô∏è WebSocket connection timeout', 'diagnosticResults');
                        ws.close();
                    }
                }, 5000);
            } catch (error) {
                showResult('error', `WebSocket test failed: ${error.message}`, 'diagnosticResults');
            }
        }

        // Generate summary report
        function generateSummary() {
            clearResults('summaryResults');
            
            let issues = [];
            let recommendations = [];
            
            // Analyze test results
            if (!testResults.health.backend) {
                issues.push('Backend is not reachable');
                recommendations.push('1. Verify Railway deployment is running');
                recommendations.push('2. Check Railway logs for errors');
                recommendations.push('3. Ensure backend URL is correct');
            }
            
            if (!testResults.health.cors) {
                issues.push('CORS configuration issues');
                recommendations.push('1. Add Vercel domain to CORS allowed origins in backend');
                recommendations.push('2. Ensure CORS middleware is properly configured');
            }
            
            if (!testResults.content.success) {
                issues.push('Content generation is failing');
                recommendations.push('1. Verify ANTHROPIC_API_KEY is set in Railway environment variables');
                recommendations.push('2. Check if API key has sufficient credits/permissions');
                recommendations.push('3. Review backend logs for Claude API errors');
            }
            
            if (!testResults.chat.success || !testResults.chat.contextMaintained) {
                issues.push('Chat sessions are not maintaining context');
                recommendations.push('1. Check Redis/session storage configuration');
                recommendations.push('2. Verify WebSocket connections are stable');
                recommendations.push('3. Review session timeout settings');
                recommendations.push('4. Implement session persistence in frontend');
            }
            
            // Display summary
            showResult('info', 'üìä DIAGNOSTIC SUMMARY', 'summaryResults');
            
            if (issues.length === 0) {
                showResult('success', '‚úÖ All systems operational!', 'summaryResults');
            } else {
                showResult('error', `Found ${issues.length} issue(s):`, 'summaryResults');
                issues.forEach(issue => {
                    showResult('warning', `‚Ä¢ ${issue}`, 'summaryResults');
                });
                
                showResult('info', '\nüìã RECOMMENDATIONS:', 'summaryResults');
                recommendations.forEach(rec => {
                    showResult('info', rec, 'summaryResults');
                });
            }
            
            // Add specific fix for environment variables
            showResult('info', '\nüîß QUICK FIX COMMANDS:', 'summaryResults');
            showResult('info', 'For Railway backend:\n1. railway variables set ANTHROPIC_API_KEY=your_key_here\n2. railway up', 'summaryResults');
            showResult('info', 'For Vercel frontend:\n1. vercel env add REACT_APP_API_URL\n2. Enter your Railway backend URL\n3. vercel --prod', 'summaryResults');
        }

        // Load config on page load
        window.onload = () => {
            loadSavedConfig();
        };
    </script>
</body>
</html>