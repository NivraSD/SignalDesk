const claudeService = require('../../config/claude');
const pool = require('../config/db');

exports.analyzeSentiment = async (req, res) => {
  try {
    const { text, source, brandContext, sentimentContext, analysisInstructions, sentimentCalibration } = req.body;
    const userId = req.user.id;

    console.log('=== Sentiment Analysis called ===');
    console.log('Text length:', text?.length || 0);
    console.log('Brand:', brandContext?.companyName || 'Not specified');

    const companyContext = brandContext?.companyName || 'the company';
    const industry = brandContext?.industry || 'general business';
    
    const prompt = `You are analyzing a mention about ${companyContext} (${industry} industry) for sentiment analysis and monitoring purposes.

Context about the company:
- Products/Services: ${brandContext?.productServices || 'Not specified'}
- Target Audience: ${brandContext?.targetAudience || 'Not specified'}
- Brand Values: ${brandContext?.brandValues || 'Not specified'}
${brandContext?.customContext ? `- Additional Context: ${brandContext.customContext}` : ''}

Sentiment Context - IMPORTANT for accurate analysis:
${sentimentContext?.positiveScenarios ? `
POSITIVE INDICATORS (things the company views as positive):
${sentimentContext.positiveScenarios}` : ''}
${sentimentContext?.negativeScenarios ? `
NEGATIVE INDICATORS (things the company is worried about):
${sentimentContext.negativeScenarios}` : ''}
${sentimentContext?.criticalConcerns ? `
CRITICAL CONCERNS (urgent issues that require immediate attention):
${sentimentContext.criticalConcerns}` : ''}

Content to analyze:
"${text}"
${source ? `\nSource: ${source}` : ''}

Provide a comprehensive analysis in the following JSON format:
{
  "sentiment": "positive/negative/neutral/mixed",
  "sentiment_score": -100 to 100,
  "confidence": 0.0 to 1.0,
  "summary": "2-3 sentence summary",
  "rationale": "Detailed explanation",
  "key_topics": ["topic1", "topic2"],
  "emotions_detected": {
    "primary": "emotion",
    "secondary": ["emotion1", "emotion2"]
  },
  "actionable_insights": ["insight1"] or null,
  "urgency_level": "critical/high/medium/low",
  "competitor_mentions": ["competitor1"] or null,
  "aspects_mentioned": [
    {
      "aspect": "aspect_name",
      "sentiment": "positive/negative/neutral",
      "detail": "specific detail"
    }
  ],
  "recommended_action": "action" or null
}

Respond ONLY with valid JSON.`;

    const response = await claudeService.generateContent(prompt);
    console.log('âœ… Claude API responded successfully');

    let analysis;
    try {
      // Parse the response
      analysis = JSON.parse(response);
    } catch (parseError) {
      console.error('Failed to parse Claude response:', parseError);
      return res.json({
        error: 'Failed to parse AI response',
        fallback: true
      });
    }

    // Save the analysis to database (optional)
    try {
      await db.query(
        `INSERT INTO monitoring_analyses (user_id, text, source, analysis, created_at)
         VALUES ($1, $2, $3, $4, NOW())`,
        [userId, text.substring(0, 1000), source, JSON.stringify(analysis)]
      );
    } catch (dbError) {
      console.error('Failed to save analysis:', dbError);
      // Continue anyway - analysis is more important than saving
    }

    res.json({
      success: true,
      analysis: analysis
    });

  } catch (error) {
    console.error('Sentiment analysis error:', error);
    res.json({
      error: 'Analysis failed',
      message: error.message
    });
  }
};

exports.analyzeBatch = async (req, res) => {
  try {
    const { mentions, brandContext, sentimentContext, analysisInstructions } = req.body;
    const userId = req.user.id;

    console.log('=== Batch Analysis called ===');
    console.log('Number of mentions:', mentions?.length || 0);

    const results = [];
    
    // Process in batches to avoid overwhelming the API
    const batchSize = 5;
    for (let i = 0; i < mentions.length; i += batchSize) {
      const batch = mentions.slice(i, i + batchSize);
      
      const batchPromises = batch.map(async (mention) => {
        try {
          const analysisReq = {
            text: mention.content,
            source: mention.source,
            brandContext,
            sentimentContext,
            analysisInstructions
          };
          
          // Call our own analyzeSentiment function
          const analysis = await this.analyzeSentiment({
            body: analysisReq,
            user: { id: userId }
          }, {
            json: (data) => data
          });
          
          return {
            mentionId: mention.id,
            analysis: analysis.analysis,
            success: true
          };
        } catch (error) {
          return {
            mentionId: mention.id,
            error: error.message,
            success: false
          };
        }
      });
      
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);
    }

    res.json({
      success: true,
      results: results,
      analyzed: results.filter(r => r.success).length,
      failed: results.filter(r => !r.success).length
    });

  } catch (error) {
    console.error('Batch analysis error:', error);
    res.status(500).json({
      success: false,
      error: 'Batch analysis failed',
      message: error.message
    });
  }
};

exports.saveConfig = async (req, res) => {
  try {
    const { config } = req.body;
    const userId = req.user.id;

    // Save or update configuration
    await db.query(
      `INSERT INTO monitoring_configs (user_id, config_data, updated_at)
       VALUES ($1, $2, NOW())
       ON CONFLICT (user_id) 
       DO UPDATE SET config_data = $2, updated_at = NOW()`,
      [userId, JSON.stringify(config)]
    );

    res.json({
      success: true,
      message: 'Configuration saved successfully'
    });

  } catch (error) {
    console.error('Save config error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to save configuration'
    });
  }
};

exports.getConfig = async (req, res) => {
  try {
    const userId = req.user.id;

    const result = await db.query(
      'SELECT config_data FROM monitoring_configs WHERE user_id = $1',
      [userId]
    );

    if (result.rows.length === 0) {
      return res.json({
        success: true,
        config: null
      });
    }

    res.json({
      success: true,
      config: result.rows[0].config_data
    });

  } catch (error) {
    console.error('Get config error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve configuration'
    });
  }
};

exports.saveMentions = async (req, res) => {
  try {
    const { mentions } = req.body;
    const userId = req.user.id;

    // Save mentions to database
    for (const mention of mentions) {
      await db.query(
        `INSERT INTO monitoring_mentions 
         (user_id, mention_id, content, source, source_type, author, publish_date, url, reach, sentiment, analysis, created_at)
         VALUES ($1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, NOW())
         ON CONFLICT (user_id, mention_id) 
         DO UPDATE SET 
           sentiment = $10, 
           analysis = $11, 
           updated_at = NOW()`,
        [
          userId,
          mention.id,
          mention.content,
          mention.source,
          mention.sourceType,
          mention.author,
          mention.publish_date,
          mention.url,
          mention.reach,
          mention.sentiment,
          JSON.stringify(mention.claudeAnalysis)
        ]
      );
    }

    res.json({
      success: true,
      saved: mentions.length
    });

  } catch (error) {
    console.error('Save mentions error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to save mentions'
    });
  }
};

exports.getMentions = async (req, res) => {
  try {
    const userId = req.user.id;
    const { limit = 100, offset = 0 } = req.query;

    const result = await db.query(
      `SELECT * FROM monitoring_mentions 
       WHERE user_id = $1 
       ORDER BY publish_date DESC 
       LIMIT $2 OFFSET $3`,
      [userId, limit, offset]
    );

    res.json({
      success: true,
      mentions: result.rows.map(row => ({
        id: row.mention_id,
        content: row.content,
        source: row.source,
        sourceType: row.source_type,
        author: row.author,
        publish_date: row.publish_date,
        url: row.url,
        reach: row.reach,
        sentiment: row.sentiment,
        claudeAnalysis: row.analysis,
        analyzedAt: row.updated_at
      })),
      total: result.rows.length
    });

  } catch (error) {
    console.error('Get mentions error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to retrieve mentions'
    });
  }
};

exports.exportData = async (req, res) => {
  try {
    const userId = req.user.id;
    const { format = 'csv', dateRange } = req.body;

    // Retrieve mentions for export
    const result = await db.query(
      `SELECT * FROM monitoring_mentions 
       WHERE user_id = $1 
       ORDER BY publish_date DESC`,
      [userId]
    );

    const mentions = result.rows;

    if (format === 'csv') {
      // Format as CSV (simplified version)
      const csv = [
        ['Date/Time', 'Source', 'Content', 'Sentiment', 'Score', 'Confidence', 'Summary', 'Key Topics', 'Urgency', 'Reach', 'Author', 'URL'],
        ...mentions.map(m => [
          m.publish_date,
          m.source,
          m.content.replace(/,/g, ';'),
          m.sentiment,
          m.analysis?.sentiment_score || 0,
          m.analysis?.confidence || 0,
          m.analysis?.summary || '',
          m.analysis?.key_topics?.join('; ') || '',
          m.analysis?.urgency_level || '',
          m.reach,
          m.author,
          m.url
        ])
      ].map(row => row.join(',')).join('\n');

      res.setHeader('Content-Type', 'text/csv');
      res.setHeader('Content-Disposition', 'attachment; filename=monitoring-export.csv');
      res.send(csv);
    } else {
      // JSON export
      res.json({
        success: true,
        exportDate: new Date().toISOString(),
        totalMentions: mentions.length,
        mentions: mentions
      });
    }

  } catch (error) {
    console.error('Export data error:', error);
    res.status(500).json({
      success: false,
      error: 'Failed to export data'
    });
  }
};
