import { NextRequest, NextResponse } from 'next/server'
import PptxGenJS from 'pptxgenjs'

export const runtime = 'nodejs'
export const dynamic = 'force-dynamic'

interface SlideData {
  type: string
  title: string
  body?: string[]
  notes?: string
  visual_element?: {
    type: string
    description?: string
    chart_type?: string
    data?: { labels: string[], values: number[] }
  }
  imageUrl?: string
}

interface PresentationData {
  title: string
  slides: SlideData[]
}

interface DesignBrief {
  visualStyle: string
  colorPalette: {
    primary: string
    secondary: string
    accent: string
    background: string
    supporting: string[]
  }
  typography: {
    titleFont: string
    bodyFont: string
    style: string
  }
  imageStyle: {
    type: string
    mood: string[]
    subjects: string[]
  }
  slideVisuals: Array<{
    slideNumber: number
    slideTitle: string
    visualType: string
    imagePrompt?: string
    chartType?: string
    layout: string
  }>
  rationale: {
    styleChoice: string
    colorPsychology: string
    typographyReason: string
    imageDirection: string
  }
}

// Legacy theme interface for backwards compatibility
interface Theme {
  primary: string
  secondary: string
  accent: string
}

export async function POST(request: NextRequest) {
  console.log('üìä Build presentation API called')

  try {
    const body = await request.json()
    const { presentationData, designBrief, slideImages, theme, organizationId } = body as {
      presentationData: PresentationData
      designBrief?: DesignBrief
      slideImages?: Record<number, string>
      theme?: Theme
      organizationId: string
    }

    if (!presentationData) {
      return NextResponse.json(
        { success: false, error: 'No presentation data provided' },
        { status: 400 }
      )
    }

    if (!presentationData.slides || !Array.isArray(presentationData.slides)) {
      console.error('Invalid presentation data - slides missing or not an array:', presentationData)
      return NextResponse.json(
        {
          success: false,
          error: 'Invalid presentation data: slides array is required',
          received: presentationData
        },
        { status: 400 }
      )
    }

    if (presentationData.slides.length === 0) {
      return NextResponse.json(
        { success: false, error: 'No slides provided in presentation data' },
        { status: 400 }
      )
    }

    console.log('üìù Presentation data:', {
      title: presentationData.title,
      slideCount: presentationData.slides.length,
      hasDesignBrief: !!designBrief,
      imageCount: slideImages ? Object.keys(slideImages).length : 0
    })

    // Create presentation
    const pptx = new PptxGenJS()

    // Set presentation properties
    pptx.author = 'NIV'
    pptx.company = organizationId || 'NIV'
    pptx.title = presentationData.title
    pptx.subject = 'Generated by NIV'

    // Use design brief colors if available, otherwise fall back to theme or defaults
    const colorPalette = designBrief?.colorPalette || {
      primary: theme?.primary || '1a1a2e',
      secondary: theme?.secondary || '16213e',
      accent: theme?.accent || '0f3460',
      background: 'ffffff',
      supporting: ['4A90E2', '50C878', 'FF6B6B', 'FFD93D']
    }

    const typography = designBrief?.typography || {
      titleFont: 'Arial',
      bodyFont: 'Arial',
      style: 'bold'
    }

    console.log('üé® Using design:', {
      style: designBrief?.visualStyle || 'default',
      primaryColor: colorPalette.primary,
      accentColor: colorPalette.accent,
      titleFont: typography.titleFont
    })

    // Helper function to clean hex colors
    const cleanHex = (color: string) => color.replace('#', '')

    // Process each slide
    for (let i = 0; i < presentationData.slides.length; i++) {
      const slideData = presentationData.slides[i]
      const slideVisual = designBrief?.slideVisuals?.[i]
      const slideImage = slideImages?.[i]
      const slide = pptx.addSlide()

      console.log(`üìÑ Adding slide ${i + 1}: ${slideData.title}${slideImage ? ' (with image)' : ''}`)

      // Set background based on design brief
      slide.background = { color: cleanHex(colorPalette.background) }

      // Get layout type
      const layout = slideVisual?.layout || 'centered'
      const visualType = slideVisual?.visualType || slideData.type

      // Title slide (first slide) or closing slides
      if (i === 0 || slideData.type === 'title' || slideData.type === 'closing') {
        if (visualType === 'hero_image' && slideImage) {
          // Full-bleed hero image
          try {
            slide.addImage({
              path: slideImage,
              x: 0,
              y: 0,
              w: '100%',
              h: '100%',
              sizing: { type: 'cover', w: 10, h: 5.625 }
            })

            // Add semi-transparent overlay for text readability
            slide.addShape(pptx.shapes.RECTANGLE, {
              x: 0,
              y: 0,
              w: '100%',
              h: 2,
              fill: { color: '000000', transparency: 50 }
            })

            // Title on top of image
            slide.addText(slideData.title, {
              x: 0.5,
              y: 0.75,
              w: 9,
              h: 1.2,
              fontSize: 54,
              bold: typography.style === 'bold',
              color: 'FFFFFF',
              align: 'center',
              valign: 'middle',
              fontFace: typography.titleFont
            })

            if (slideData.body && slideData.body.length > 0) {
              slide.addText(slideData.body.join('\n'), {
                x: 1,
                y: 2.2,
                w: 8,
                h: 1,
                fontSize: 24,
                color: 'FFFFFF',
                align: 'center',
                fontFace: typography.bodyFont
              })
            }
          } catch (error) {
            console.error('  ‚ö†Ô∏è Error adding hero image:', error)
            // Fall back to text-only slide
            slide.addText(slideData.title, {
              x: 0.5,
              y: 2.5,
              w: 9,
              h: 1.5,
              fontSize: 44,
              bold: true,
              color: cleanHex(colorPalette.primary),
              align: 'center',
              valign: 'middle',
              fontFace: typography.titleFont
            })
          }
        } else {
          // Text-only title/closing slide
          slide.addText(slideData.title, {
            x: 0.5,
            y: 2.5,
            w: 9,
            h: 1.5,
            fontSize: 44,
            bold: true,
            color: cleanHex(colorPalette.primary),
            align: 'center',
            valign: 'middle',
            fontFace: typography.titleFont
          })

          if (slideData.body && slideData.body.length > 0) {
            slide.addText(slideData.body.join('\n'), {
              x: 1,
              y: 4.5,
              w: 8,
              h: 1,
              fontSize: 20,
              color: cleanHex(colorPalette.secondary),
              align: 'center',
              fontFace: typography.bodyFont
            })
          }
        }
      }
      // Content slides
      else {
        // Determine layout based on visual type and available content
        const hasChart = slideData.visual_element?.type === 'chart' && slideData.visual_element?.data
        const hasImage = !!slideImage
        const useSideBySide = (hasChart || hasImage) && layout === 'side_by_side'

        // Add title
        slide.addText(slideData.title, {
          x: 0.5,
          y: 0.5,
          w: 9,
          h: 0.8,
          fontSize: 32,
          bold: true,
          color: cleanHex(colorPalette.primary),
          fontFace: typography.titleFont
        })

        // Add body content
        if (slideData.body && slideData.body.length > 0) {
          const bulletText = slideData.body.map(point => ({
            text: point,
            options: {
              bullet: true,
              color: cleanHex(colorPalette.secondary),
              fontSize: useSideBySide ? 14 : 18,
              fontFace: typography.bodyFont
            }
          }))

          slide.addText(bulletText, {
            x: 0.75,
            y: 1.5,
            w: useSideBySide ? 4 : 8.5,
            h: useSideBySide ? 4.5 : 4,
            fontSize: useSideBySide ? 14 : 18,
            color: cleanHex(colorPalette.secondary)
          })
        }

        // Add visual elements (images or charts)
        if (hasImage) {
          try {
            console.log(`  üñºÔ∏è Adding AI-generated image`)
            slide.addImage({
              path: slideImage,
              x: 5,
              y: 1.5,
              w: 4.5,
              h: 4.5,
              sizing: { type: 'contain', w: 4.5, h: 4.5 }
            })
          } catch (error) {
            console.error('  ‚ö†Ô∏è Error adding image:', error)
          }
        } else if (hasChart) {
          const chartType = slideData.visual_element?.chart_type || 'bar'
          const chartData = slideData.visual_element!.data!

          console.log(`  üìä Adding ${chartType} chart with ${chartData.labels.length} data points`)

          slide.addChart(
            pptx.ChartType[chartType as keyof typeof pptx.ChartType] || pptx.ChartType.bar,
            [
              {
                name: slideData.visual_element?.description || slideData.title,
                labels: chartData.labels,
                values: chartData.values
              }
            ],
            {
              x: 5,
              y: 1.5,
              w: 4.5,
              h: 4.5,
              showTitle: true,
              showLegend: true,
              showValue: true,
              chartColors: [
                cleanHex(colorPalette.accent),
                ...colorPalette.supporting.map(c => cleanHex(c))
              ],
              titleFontSize: 14,
              titleColor: cleanHex(colorPalette.primary),
              valAxisLabelFontSize: 11,
              catAxisLabelFontSize: 11
            }
          )
        }

        // Add speaker notes
        if (slideData.notes) {
          slide.addNotes(slideData.notes)
        }
      }
    }

    // Generate the PowerPoint file
    console.log('üì¶ Generating .pptx file...')
    const pptxData = await pptx.write({ outputType: 'base64' }) as string

    const timestamp = Date.now()
    const fileName = `presentation-${organizationId || 'default'}-${timestamp}.pptx`

    console.log('‚úÖ PowerPoint generated:', fileName)

    // Return file data
    return NextResponse.json({
      success: true,
      fileName,
      filePath: `/tmp/${fileName}`,
      fileSize: Math.round((pptxData.length * 3) / 4),
      fileData: pptxData,
      metadata: {
        title: presentationData.title,
        slideCount: presentationData.slides?.length,
        hasDesignBrief: !!designBrief,
        visualStyle: designBrief?.visualStyle,
        imageCount: slideImages ? Object.keys(slideImages).length : 0,
        generated: new Date().toISOString()
      }
    })

  } catch (error) {
    console.error('‚ùå Build presentation error:', error)

    return NextResponse.json(
      {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error',
        details: error instanceof Error ? error.stack : undefined
      },
      { status: 500 }
    )
  }
}

// Health check endpoint
export async function GET(request: NextRequest) {
  return NextResponse.json({
    success: true,
    message: 'SignalDeck presentation builder API with Creative Orchestration is running',
    version: '2.0.0',
    features: [
      'Design Brief Support',
      'AI Image Integration',
      'Custom Color Palettes',
      'Typography Control',
      'Multiple Layout Types'
    ]
  })
}
