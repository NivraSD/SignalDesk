{"ast":null,"code":"import axios from 'axios';\nimport API_BASE_URL from '../config/api';\nconst STAKEHOLDER_API_BASE = `${API_BASE_URL}/stakeholder-intelligence`;\n\n// Get auth token from localStorage\nconst getAuthHeaders = () => {\n  const token = localStorage.getItem('token');\n  return {\n    'Content-Type': 'application/json',\n    'Authorization': token ? `Bearer ${token}` : ''\n  };\n};\nclass StakeholderIntelligenceService {\n  // Organization Management\n  async createOrUpdateOrganization(orgData) {\n    try {\n      const response = await axios.post(`${STAKEHOLDER_API_BASE}/organization`, orgData, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error creating organization:', error);\n      throw error;\n    }\n  }\n\n  // Generate AI-powered stakeholder suggestions\n  async generateStakeholderSuggestions(orgData) {\n    try {\n      const response = await axios.post(`${STAKEHOLDER_API_BASE}/suggestions`, {\n        company: orgData.company,\n        url: orgData.url,\n        strategicGoals: orgData.strategicGoals,\n        priorityStakeholders: orgData.priorityStakeholders\n      }, {\n        headers: getAuthHeaders()\n      });\n      return response.data.suggestions;\n    } catch (error) {\n      console.error('Error generating suggestions:', error);\n      // Fallback to local generation if API fails\n      return this.generateLocalSuggestions(orgData);\n    }\n  }\n\n  // Discover sources for a stakeholder using external APIs\n  async discoverStakeholderSources(stakeholderName, stakeholderType) {\n    try {\n      const response = await axios.post(`${STAKEHOLDER_API_BASE}/discover-sources`, {\n        stakeholderName,\n        stakeholderType\n      }, {\n        headers: getAuthHeaders()\n      });\n      return response.data.sources;\n    } catch (error) {\n      console.error('Error discovering sources:', error);\n      return [];\n    }\n  }\n\n  // Validate a source URL\n  async validateSource(url) {\n    try {\n      const response = await axios.post(`${STAKEHOLDER_API_BASE}/validate-source`, {\n        url\n      }, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error validating source:', error);\n      return {\n        valid: false,\n        error: error.message\n      };\n    }\n  }\n\n  // Save stakeholder configuration\n  async saveStakeholderConfiguration(organizationId, stakeholders) {\n    try {\n      const response = await axios.post(`${STAKEHOLDER_API_BASE}/configure`, {\n        organizationId,\n        stakeholders\n      }, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error saving configuration:', error);\n      throw error;\n    }\n  }\n\n  // Get monitoring data for an organization\n  async getStakeholderMonitoring(organizationId) {\n    try {\n      const response = await axios.get(`${STAKEHOLDER_API_BASE}/monitoring/${organizationId}`, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error getting monitoring data:', error);\n      return {\n        stakeholders: [],\n        findings: [],\n        predictions: []\n      };\n    }\n  }\n\n  // Run monitoring scan\n  async runMonitoringScan(organizationId) {\n    try {\n      const response = await axios.post(`${STAKEHOLDER_API_BASE}/scan`, {\n        organizationId\n      }, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error running scan:', error);\n      throw error;\n    }\n  }\n\n  // Get intelligence findings\n  async getIntelligenceFindings(organizationId, options = {}) {\n    try {\n      const params = new URLSearchParams();\n      if (options.limit) params.append('limit', options.limit);\n      if (options.offset) params.append('offset', options.offset);\n      if (options.unreadOnly) params.append('unreadOnly', options.unreadOnly);\n      const response = await axios.get(`${STAKEHOLDER_API_BASE}/findings/${organizationId}?${params.toString()}`, {\n        headers: getAuthHeaders()\n      });\n      return response.data.findings;\n    } catch (error) {\n      console.error('Error getting findings:', error);\n      return [];\n    }\n  }\n\n  // Discover sources for a stakeholder\n  async discoverSourcesForStakeholder(stakeholder) {\n    try {\n      console.log('Discovering sources for stakeholder:', stakeholder);\n      const requestData = {\n        stakeholderName: stakeholder.name,\n        stakeholderType: stakeholder.type\n      };\n      console.log('Request data:', requestData);\n      console.log('API URL:', `${STAKEHOLDER_API_BASE}/discover-sources`);\n      const response = await axios.post(`${STAKEHOLDER_API_BASE}/discover-sources`, requestData, {\n        headers: getAuthHeaders()\n      });\n      console.log('Source discovery response:', response.data);\n      if (response.data.success && response.data.sources) {\n        console.log('Returning', response.data.sources.length, 'sources');\n        return response.data.sources;\n      }\n      console.log('No sources in response');\n      return [];\n    } catch (error) {\n      var _error$response;\n      console.error('Error discovering sources:', error);\n      console.error('Error details:', ((_error$response = error.response) === null || _error$response === void 0 ? void 0 : _error$response.data) || error.message);\n      return [];\n    }\n  }\n\n  // Validate a source URL\n  async validateSource(url) {\n    try {\n      const response = await axios.post(`${STAKEHOLDER_API_BASE}/validate-source`, {\n        url\n      }, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error validating source:', error);\n      return {\n        valid: false\n      };\n    }\n  }\n\n  // Batch validate multiple sources\n  async batchValidateSources(urls) {\n    const results = await Promise.allSettled(urls.map(url => this.validateSource(url)));\n    return results.map(result => result.status === 'fulfilled' ? result.value : {\n      valid: false\n    });\n  }\n\n  // Mark finding as read\n  async markFindingAsRead(findingId) {\n    try {\n      const response = await axios.put(`${STAKEHOLDER_API_BASE}/findings/${findingId}/read`, {}, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error marking finding as read:', error);\n      throw error;\n    }\n  }\n\n  // Archive finding\n  async archiveFinding(findingId) {\n    try {\n      const response = await axios.put(`${STAKEHOLDER_API_BASE}/findings/${findingId}/archive`, {}, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error archiving finding:', error);\n      throw error;\n    }\n  }\n\n  // Get predictions\n  async getPredictions(organizationId) {\n    try {\n      const response = await axios.get(`${STAKEHOLDER_API_BASE}/predictions/${organizationId}`, {\n        headers: getAuthHeaders()\n      });\n      return response.data.predictions;\n    } catch (error) {\n      console.error('Error getting predictions:', error);\n      return [];\n    }\n  }\n\n  // Get recommended actions\n  async getRecommendedActions(organizationId, status = 'pending') {\n    try {\n      const response = await axios.get(`${STAKEHOLDER_API_BASE}/actions/${organizationId}?status=${status}`, {\n        headers: getAuthHeaders()\n      });\n      return response.data.actions;\n    } catch (error) {\n      console.error('Error getting actions:', error);\n      return [];\n    }\n  }\n\n  // Update action status\n  async updateAction(actionId, updates) {\n    try {\n      const response = await axios.put(`${STAKEHOLDER_API_BASE}/actions/${actionId}`, updates, {\n        headers: getAuthHeaders()\n      });\n      return response.data;\n    } catch (error) {\n      console.error('Error updating action:', error);\n      throw error;\n    }\n  }\n\n  // Get dashboard summary\n  async getDashboardSummary(organizationId) {\n    try {\n      const response = await axios.get(`${STAKEHOLDER_API_BASE}/dashboard/${organizationId}`, {\n        headers: getAuthHeaders()\n      });\n      return response.data.summary;\n    } catch (error) {\n      console.error('Error getting dashboard summary:', error);\n      return {\n        stakeholders: {},\n        findings: {},\n        actions: {}\n      };\n    }\n  }\n\n  // Check for pre-indexed stakeholder\n  async checkPreIndexedStakeholder(name) {\n    try {\n      const response = await axios.get(`${STAKEHOLDER_API_BASE}/pre-indexed/${encodeURIComponent(name)}`, {\n        headers: getAuthHeaders()\n      });\n      return response.data.stakeholders;\n    } catch (error) {\n      console.error('Error checking pre-indexed stakeholder:', error);\n      return [];\n    }\n  }\n\n  // Local fallback for suggestions if API fails\n  generateLocalSuggestions(orgData) {\n    var _orgData$company, _orgData$strategicGoa;\n    const suggestions = [];\n    const companyName = ((_orgData$company = orgData.company) === null || _orgData$company === void 0 ? void 0 : _orgData$company.toLowerCase()) || '';\n    const goals = ((_orgData$strategicGoa = orgData.strategicGoals) === null || _orgData$strategicGoa === void 0 ? void 0 : _orgData$strategicGoa.toLowerCase()) || '';\n\n    // Check if it's a PR/marketing agency\n    if (companyName.includes('karv') || companyName.includes('pr') || companyName.includes('communications') || goals.includes('new business')) {\n      if (goals.includes('tech')) {\n        // PR Agency targeting tech\n        suggestions.push({\n          name: 'Microsoft',\n          type: 'Target Client',\n          priority: 'critical',\n          reason: 'Major tech company needing PR services',\n          monitoringTopics: ['product launches', 'PR RFPs', 'crisis situations']\n        }, {\n          name: 'Sequoia Capital',\n          type: 'Referral Partner',\n          priority: 'high',\n          reason: 'Top VC that refers PR agencies to portfolio',\n          monitoringTopics: ['new investments', 'portfolio needs']\n        }, {\n          name: 'TechCrunch',\n          type: 'Media Partner',\n          priority: 'high',\n          reason: 'Key tech media for client coverage',\n          monitoringTopics: ['reporter beats', 'editorial calendar']\n        });\n      }\n    } else {\n      // Default B2B suggestions\n      suggestions.push({\n        name: 'Enterprise Customers',\n        type: 'Revenue Drivers',\n        priority: 'critical',\n        reason: 'Key customers and prospects',\n        monitoringTopics: ['RFPs', 'budget cycles', 'vendor evaluations']\n      });\n    }\n    return suggestions;\n  }\n\n  // Batch operations for efficiency\n  async batchValidateSources(urls) {\n    const validationPromises = urls.map(url => this.validateSource(url));\n    const results = await Promise.allSettled(validationPromises);\n    return results.map((result, index) => ({\n      url: urls[index],\n      valid: result.status === 'fulfilled' && result.value.valid,\n      error: result.status === 'rejected' ? result.reason : null\n    }));\n  }\n\n  // Analyze data with AI\n  async analyzeWithAI(context) {\n    try {\n      var _context$dataPoints;\n      // For now, return a basic analysis structure\n      // In production, this would call the backend AI service\n      return {\n        analysis: {\n          summary: `Analysis of ${context.stakeholderName}: ${((_context$dataPoints = context.dataPoints) === null || _context$dataPoints === void 0 ? void 0 : _context$dataPoints.length) || 0} data points analyzed`,\n          sentiment: this.calculateSentiment(context.dataPoints),\n          keyThemes: this.extractThemes(context.dataPoints),\n          risks: this.identifyRisks(context.dataPoints),\n          opportunities: this.identifyOpportunities(context.dataPoints)\n        }\n      };\n    } catch (error) {\n      console.error('Error in AI analysis:', error);\n      return null;\n    }\n  }\n\n  // Helper methods for AI analysis\n  calculateSentiment(dataPoints) {\n    if (!dataPoints || dataPoints.length === 0) return 'neutral';\n    const positiveWords = ['growth', 'success', 'innovative', 'leading', 'partnership', 'expansion'];\n    const negativeWords = ['concern', 'risk', 'decline', 'issue', 'problem', 'challenge'];\n    let positiveCount = 0;\n    let negativeCount = 0;\n    dataPoints.forEach(point => {\n      const text = (point.title + ' ' + point.content).toLowerCase();\n      positiveWords.forEach(word => {\n        if (text.includes(word)) positiveCount++;\n      });\n      negativeWords.forEach(word => {\n        if (text.includes(word)) negativeCount++;\n      });\n    });\n    if (positiveCount > negativeCount * 2) return 'positive';\n    if (negativeCount > positiveCount * 2) return 'negative';\n    return 'neutral';\n  }\n  extractThemes(dataPoints) {\n    if (!dataPoints || dataPoints.length === 0) return [];\n    const themes = [];\n    const themeKeywords = {\n      'innovation': ['innovation', 'new', 'launch', 'technology'],\n      'growth': ['growth', 'expansion', 'increase', 'rising'],\n      'partnership': ['partner', 'collaboration', 'alliance', 'deal'],\n      'leadership': ['CEO', 'executive', 'leadership', 'appointment']\n    };\n    const allText = dataPoints.map(p => (p.title + ' ' + p.content).toLowerCase()).join(' ');\n    Object.entries(themeKeywords).forEach(([theme, keywords]) => {\n      if (keywords.some(keyword => allText.includes(keyword))) {\n        themes.push(theme);\n      }\n    });\n    return themes;\n  }\n  identifyRisks(dataPoints) {\n    if (!dataPoints || dataPoints.length === 0) return [];\n    const risks = [];\n    const riskKeywords = ['risk', 'concern', 'issue', 'problem', 'challenge', 'threat'];\n    dataPoints.forEach(point => {\n      const text = (point.title + ' ' + point.content).toLowerCase();\n      if (riskKeywords.some(keyword => text.includes(keyword))) {\n        risks.push('Potential concerns identified in recent coverage');\n        return;\n      }\n    });\n    return [...new Set(risks)];\n  }\n  identifyOpportunities(dataPoints) {\n    if (!dataPoints || dataPoints.length === 0) return [];\n    const opportunities = [];\n    const oppKeywords = ['opportunity', 'growth', 'expansion', 'partnership', 'innovation'];\n    dataPoints.forEach(point => {\n      const text = (point.title + ' ' + point.content).toLowerCase();\n      if (oppKeywords.some(keyword => text.includes(keyword))) {\n        opportunities.push('Positive developments detected');\n        return;\n      }\n    });\n    return [...new Set(opportunities)];\n  }\n\n  // Real-time monitoring subscription (for future WebSocket implementation)\n  subscribeToMonitoring(organizationId, callback) {\n    // This would be implemented with WebSockets for real-time updates\n    console.log('Real-time monitoring subscription not yet implemented');\n    // For now, poll every 5 minutes\n    const interval = setInterval(async () => {\n      const data = await this.getStakeholderMonitoring(organizationId);\n      callback(data);\n    }, 5 * 60 * 1000);\n    return () => clearInterval(interval);\n  }\n}\nexport default new StakeholderIntelligenceService();","map":{"version":3,"names":["axios","API_BASE_URL","STAKEHOLDER_API_BASE","getAuthHeaders","token","localStorage","getItem","StakeholderIntelligenceService","createOrUpdateOrganization","orgData","response","post","headers","data","error","console","generateStakeholderSuggestions","company","url","strategicGoals","priorityStakeholders","suggestions","generateLocalSuggestions","discoverStakeholderSources","stakeholderName","stakeholderType","sources","validateSource","valid","message","saveStakeholderConfiguration","organizationId","stakeholders","getStakeholderMonitoring","get","findings","predictions","runMonitoringScan","getIntelligenceFindings","options","params","URLSearchParams","limit","append","offset","unreadOnly","toString","discoverSourcesForStakeholder","stakeholder","log","requestData","name","type","success","length","_error$response","batchValidateSources","urls","results","Promise","allSettled","map","result","status","value","markFindingAsRead","findingId","put","archiveFinding","getPredictions","getRecommendedActions","actions","updateAction","actionId","updates","getDashboardSummary","summary","checkPreIndexedStakeholder","encodeURIComponent","_orgData$company","_orgData$strategicGoa","companyName","toLowerCase","goals","includes","push","priority","reason","monitoringTopics","validationPromises","index","analyzeWithAI","context","_context$dataPoints","analysis","dataPoints","sentiment","calculateSentiment","keyThemes","extractThemes","risks","identifyRisks","opportunities","identifyOpportunities","positiveWords","negativeWords","positiveCount","negativeCount","forEach","point","text","title","content","word","themes","themeKeywords","allText","p","join","Object","entries","theme","keywords","some","keyword","riskKeywords","Set","oppKeywords","subscribeToMonitoring","callback","interval","setInterval","clearInterval"],"sources":["/Users/jonathanliebowitz/Desktop/SignalDesk/frontend/src/services/stakeholderIntelligenceService.js"],"sourcesContent":["import axios from 'axios';\nimport API_BASE_URL from '../config/api';\n\nconst STAKEHOLDER_API_BASE = `${API_BASE_URL}/stakeholder-intelligence`;\n\n// Get auth token from localStorage\nconst getAuthHeaders = () => {\n  const token = localStorage.getItem('token');\n  return {\n    'Content-Type': 'application/json',\n    'Authorization': token ? `Bearer ${token}` : ''\n  };\n};\n\nclass StakeholderIntelligenceService {\n  // Organization Management\n  async createOrUpdateOrganization(orgData) {\n    try {\n      const response = await axios.post(\n        `${STAKEHOLDER_API_BASE}/organization`,\n        orgData,\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error creating organization:', error);\n      throw error;\n    }\n  }\n\n  // Generate AI-powered stakeholder suggestions\n  async generateStakeholderSuggestions(orgData) {\n    try {\n      const response = await axios.post(\n        `${STAKEHOLDER_API_BASE}/suggestions`,\n        {\n          company: orgData.company,\n          url: orgData.url,\n          strategicGoals: orgData.strategicGoals,\n          priorityStakeholders: orgData.priorityStakeholders\n        },\n        { headers: getAuthHeaders() }\n      );\n      return response.data.suggestions;\n    } catch (error) {\n      console.error('Error generating suggestions:', error);\n      // Fallback to local generation if API fails\n      return this.generateLocalSuggestions(orgData);\n    }\n  }\n\n  // Discover sources for a stakeholder using external APIs\n  async discoverStakeholderSources(stakeholderName, stakeholderType) {\n    try {\n      const response = await axios.post(\n        `${STAKEHOLDER_API_BASE}/discover-sources`,\n        {\n          stakeholderName,\n          stakeholderType\n        },\n        { headers: getAuthHeaders() }\n      );\n      return response.data.sources;\n    } catch (error) {\n      console.error('Error discovering sources:', error);\n      return [];\n    }\n  }\n\n  // Validate a source URL\n  async validateSource(url) {\n    try {\n      const response = await axios.post(\n        `${STAKEHOLDER_API_BASE}/validate-source`,\n        { url },\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error validating source:', error);\n      return { valid: false, error: error.message };\n    }\n  }\n\n  // Save stakeholder configuration\n  async saveStakeholderConfiguration(organizationId, stakeholders) {\n    try {\n      const response = await axios.post(\n        `${STAKEHOLDER_API_BASE}/configure`,\n        {\n          organizationId,\n          stakeholders\n        },\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error saving configuration:', error);\n      throw error;\n    }\n  }\n\n  // Get monitoring data for an organization\n  async getStakeholderMonitoring(organizationId) {\n    try {\n      const response = await axios.get(\n        `${STAKEHOLDER_API_BASE}/monitoring/${organizationId}`,\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error getting monitoring data:', error);\n      return { stakeholders: [], findings: [], predictions: [] };\n    }\n  }\n\n  // Run monitoring scan\n  async runMonitoringScan(organizationId) {\n    try {\n      const response = await axios.post(\n        `${STAKEHOLDER_API_BASE}/scan`,\n        { organizationId },\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error running scan:', error);\n      throw error;\n    }\n  }\n\n  // Get intelligence findings\n  async getIntelligenceFindings(organizationId, options = {}) {\n    try {\n      const params = new URLSearchParams();\n      if (options.limit) params.append('limit', options.limit);\n      if (options.offset) params.append('offset', options.offset);\n      if (options.unreadOnly) params.append('unreadOnly', options.unreadOnly);\n\n      const response = await axios.get(\n        `${STAKEHOLDER_API_BASE}/findings/${organizationId}?${params.toString()}`,\n        { headers: getAuthHeaders() }\n      );\n      return response.data.findings;\n    } catch (error) {\n      console.error('Error getting findings:', error);\n      return [];\n    }\n  }\n\n  // Discover sources for a stakeholder\n  async discoverSourcesForStakeholder(stakeholder) {\n    try {\n      console.log('Discovering sources for stakeholder:', stakeholder);\n      const requestData = { \n        stakeholderName: stakeholder.name,\n        stakeholderType: stakeholder.type \n      };\n      console.log('Request data:', requestData);\n      console.log('API URL:', `${STAKEHOLDER_API_BASE}/discover-sources`);\n      \n      const response = await axios.post(\n        `${STAKEHOLDER_API_BASE}/discover-sources`,\n        requestData,\n        { headers: getAuthHeaders() }\n      );\n      \n      console.log('Source discovery response:', response.data);\n      \n      if (response.data.success && response.data.sources) {\n        console.log('Returning', response.data.sources.length, 'sources');\n        return response.data.sources;\n      }\n      console.log('No sources in response');\n      return [];\n    } catch (error) {\n      console.error('Error discovering sources:', error);\n      console.error('Error details:', error.response?.data || error.message);\n      return [];\n    }\n  }\n\n  // Validate a source URL\n  async validateSource(url) {\n    try {\n      const response = await axios.post(\n        `${STAKEHOLDER_API_BASE}/validate-source`,\n        { url },\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error validating source:', error);\n      return { valid: false };\n    }\n  }\n\n  // Batch validate multiple sources\n  async batchValidateSources(urls) {\n    const results = await Promise.allSettled(\n      urls.map(url => this.validateSource(url))\n    );\n    return results.map(result => \n      result.status === 'fulfilled' ? result.value : { valid: false }\n    );\n  }\n\n  // Mark finding as read\n  async markFindingAsRead(findingId) {\n    try {\n      const response = await axios.put(\n        `${STAKEHOLDER_API_BASE}/findings/${findingId}/read`,\n        {},\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error marking finding as read:', error);\n      throw error;\n    }\n  }\n\n  // Archive finding\n  async archiveFinding(findingId) {\n    try {\n      const response = await axios.put(\n        `${STAKEHOLDER_API_BASE}/findings/${findingId}/archive`,\n        {},\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error archiving finding:', error);\n      throw error;\n    }\n  }\n\n  // Get predictions\n  async getPredictions(organizationId) {\n    try {\n      const response = await axios.get(\n        `${STAKEHOLDER_API_BASE}/predictions/${organizationId}`,\n        { headers: getAuthHeaders() }\n      );\n      return response.data.predictions;\n    } catch (error) {\n      console.error('Error getting predictions:', error);\n      return [];\n    }\n  }\n\n  // Get recommended actions\n  async getRecommendedActions(organizationId, status = 'pending') {\n    try {\n      const response = await axios.get(\n        `${STAKEHOLDER_API_BASE}/actions/${organizationId}?status=${status}`,\n        { headers: getAuthHeaders() }\n      );\n      return response.data.actions;\n    } catch (error) {\n      console.error('Error getting actions:', error);\n      return [];\n    }\n  }\n\n  // Update action status\n  async updateAction(actionId, updates) {\n    try {\n      const response = await axios.put(\n        `${STAKEHOLDER_API_BASE}/actions/${actionId}`,\n        updates,\n        { headers: getAuthHeaders() }\n      );\n      return response.data;\n    } catch (error) {\n      console.error('Error updating action:', error);\n      throw error;\n    }\n  }\n\n  // Get dashboard summary\n  async getDashboardSummary(organizationId) {\n    try {\n      const response = await axios.get(\n        `${STAKEHOLDER_API_BASE}/dashboard/${organizationId}`,\n        { headers: getAuthHeaders() }\n      );\n      return response.data.summary;\n    } catch (error) {\n      console.error('Error getting dashboard summary:', error);\n      return {\n        stakeholders: {},\n        findings: {},\n        actions: {}\n      };\n    }\n  }\n\n  // Check for pre-indexed stakeholder\n  async checkPreIndexedStakeholder(name) {\n    try {\n      const response = await axios.get(\n        `${STAKEHOLDER_API_BASE}/pre-indexed/${encodeURIComponent(name)}`,\n        { headers: getAuthHeaders() }\n      );\n      return response.data.stakeholders;\n    } catch (error) {\n      console.error('Error checking pre-indexed stakeholder:', error);\n      return [];\n    }\n  }\n\n  // Local fallback for suggestions if API fails\n  generateLocalSuggestions(orgData) {\n    const suggestions = [];\n    const companyName = orgData.company?.toLowerCase() || '';\n    const goals = orgData.strategicGoals?.toLowerCase() || '';\n    \n    // Check if it's a PR/marketing agency\n    if (companyName.includes('karv') || companyName.includes('pr') || \n        companyName.includes('communications') || goals.includes('new business')) {\n      \n      if (goals.includes('tech')) {\n        // PR Agency targeting tech\n        suggestions.push(\n          {\n            name: 'Microsoft',\n            type: 'Target Client',\n            priority: 'critical',\n            reason: 'Major tech company needing PR services',\n            monitoringTopics: ['product launches', 'PR RFPs', 'crisis situations']\n          },\n          {\n            name: 'Sequoia Capital',\n            type: 'Referral Partner',\n            priority: 'high',\n            reason: 'Top VC that refers PR agencies to portfolio',\n            monitoringTopics: ['new investments', 'portfolio needs']\n          },\n          {\n            name: 'TechCrunch',\n            type: 'Media Partner',\n            priority: 'high',\n            reason: 'Key tech media for client coverage',\n            monitoringTopics: ['reporter beats', 'editorial calendar']\n          }\n        );\n      }\n    } else {\n      // Default B2B suggestions\n      suggestions.push(\n        {\n          name: 'Enterprise Customers',\n          type: 'Revenue Drivers',\n          priority: 'critical',\n          reason: 'Key customers and prospects',\n          monitoringTopics: ['RFPs', 'budget cycles', 'vendor evaluations']\n        }\n      );\n    }\n    \n    return suggestions;\n  }\n\n  // Batch operations for efficiency\n  async batchValidateSources(urls) {\n    const validationPromises = urls.map(url => this.validateSource(url));\n    const results = await Promise.allSettled(validationPromises);\n    \n    return results.map((result, index) => ({\n      url: urls[index],\n      valid: result.status === 'fulfilled' && result.value.valid,\n      error: result.status === 'rejected' ? result.reason : null\n    }));\n  }\n\n  // Analyze data with AI\n  async analyzeWithAI(context) {\n    try {\n      // For now, return a basic analysis structure\n      // In production, this would call the backend AI service\n      return {\n        analysis: {\n          summary: `Analysis of ${context.stakeholderName}: ${context.dataPoints?.length || 0} data points analyzed`,\n          sentiment: this.calculateSentiment(context.dataPoints),\n          keyThemes: this.extractThemes(context.dataPoints),\n          risks: this.identifyRisks(context.dataPoints),\n          opportunities: this.identifyOpportunities(context.dataPoints)\n        }\n      };\n    } catch (error) {\n      console.error('Error in AI analysis:', error);\n      return null;\n    }\n  }\n\n  // Helper methods for AI analysis\n  calculateSentiment(dataPoints) {\n    if (!dataPoints || dataPoints.length === 0) return 'neutral';\n    \n    const positiveWords = ['growth', 'success', 'innovative', 'leading', 'partnership', 'expansion'];\n    const negativeWords = ['concern', 'risk', 'decline', 'issue', 'problem', 'challenge'];\n    \n    let positiveCount = 0;\n    let negativeCount = 0;\n    \n    dataPoints.forEach(point => {\n      const text = (point.title + ' ' + point.content).toLowerCase();\n      positiveWords.forEach(word => {\n        if (text.includes(word)) positiveCount++;\n      });\n      negativeWords.forEach(word => {\n        if (text.includes(word)) negativeCount++;\n      });\n    });\n    \n    if (positiveCount > negativeCount * 2) return 'positive';\n    if (negativeCount > positiveCount * 2) return 'negative';\n    return 'neutral';\n  }\n\n  extractThemes(dataPoints) {\n    if (!dataPoints || dataPoints.length === 0) return [];\n    \n    const themes = [];\n    const themeKeywords = {\n      'innovation': ['innovation', 'new', 'launch', 'technology'],\n      'growth': ['growth', 'expansion', 'increase', 'rising'],\n      'partnership': ['partner', 'collaboration', 'alliance', 'deal'],\n      'leadership': ['CEO', 'executive', 'leadership', 'appointment']\n    };\n    \n    const allText = dataPoints.map(p => (p.title + ' ' + p.content).toLowerCase()).join(' ');\n    \n    Object.entries(themeKeywords).forEach(([theme, keywords]) => {\n      if (keywords.some(keyword => allText.includes(keyword))) {\n        themes.push(theme);\n      }\n    });\n    \n    return themes;\n  }\n\n  identifyRisks(dataPoints) {\n    if (!dataPoints || dataPoints.length === 0) return [];\n    \n    const risks = [];\n    const riskKeywords = ['risk', 'concern', 'issue', 'problem', 'challenge', 'threat'];\n    \n    dataPoints.forEach(point => {\n      const text = (point.title + ' ' + point.content).toLowerCase();\n      if (riskKeywords.some(keyword => text.includes(keyword))) {\n        risks.push('Potential concerns identified in recent coverage');\n        return;\n      }\n    });\n    \n    return [...new Set(risks)];\n  }\n\n  identifyOpportunities(dataPoints) {\n    if (!dataPoints || dataPoints.length === 0) return [];\n    \n    const opportunities = [];\n    const oppKeywords = ['opportunity', 'growth', 'expansion', 'partnership', 'innovation'];\n    \n    dataPoints.forEach(point => {\n      const text = (point.title + ' ' + point.content).toLowerCase();\n      if (oppKeywords.some(keyword => text.includes(keyword))) {\n        opportunities.push('Positive developments detected');\n        return;\n      }\n    });\n    \n    return [...new Set(opportunities)];\n  }\n\n  // Real-time monitoring subscription (for future WebSocket implementation)\n  subscribeToMonitoring(organizationId, callback) {\n    // This would be implemented with WebSockets for real-time updates\n    console.log('Real-time monitoring subscription not yet implemented');\n    // For now, poll every 5 minutes\n    const interval = setInterval(async () => {\n      const data = await this.getStakeholderMonitoring(organizationId);\n      callback(data);\n    }, 5 * 60 * 1000);\n    \n    return () => clearInterval(interval);\n  }\n}\n\nexport default new StakeholderIntelligenceService();"],"mappings":"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","ignoreList":[]},"metadata":{},"sourceType":"module","externalDependencies":[]}